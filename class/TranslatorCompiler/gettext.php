<?php
/**
 * @version $Revision: 466 $
 */

require_once(SITE_PATH. '/class/FileSystem.php');

/**
 * Gettext language file compiler
 *
 * @author Alexandr Chertkov <s6urik@modera.net>
 * @see Translator_gettext
 * @todo skip plural translations where not all forms are translated
 */
class TranslatorCompiler_gettext extends TranslatorCompiler
{
    /**
     * Resource of opened PO file
     *
     * @var resource
     * @access private
     */
    var $_fp;

    /**
     * Path to directory for current language files
     *
     * @var string
     * @access private
     */
    var $_lang_path;

    /*Private******************************************************************/

    /**#@+
     * @access private
     */

    /**
     * Write PO header
     *
     * @param resource $fp
     */
    function _write_header($fp)
    {
        $header = "# AUTOGENERATED LANGUAGE FILE\n";
        $header .= "msgid \"\"\n";
        $header .= "msgstr \"\"\n";

        foreach (array_merge($this->_def_params(), $this->_params) as $param => $value) {
            if (false !== ($l = substr($param, 0, 1)) && ord($l) >= 65 && ord($l) <= 90
                && !empty($value))
            {
                // include in file header only params that starts with capital letters
                $value = $this->_escape_str($value);
                $header .= "\"$param: $value\\n\"\n";
            }
        }

        $header .= "\"Plural-Forms: nplurals={$this->_params['nplurals']}; plural="
            . ('' === $this->_params['expr'] ? '0' : $this->_params['expr']) . ";\\n\"\n";

        fwrite($fp, $header);
    }

    /**
     * Escape string before using it in language file
     *
     * @param string $str
     * @return string
     */
    function _escape_str($str)
    {
        // msgfmt will not compile .po file if it will meet that msgid ends with '\n' but
        // msgstr do not and vice versa, that's why we will strip all newlines from the end
        // of input string
        return strtr(rtrim($str, "\r\n"), array('\\' => '\\\\', '"' => '\"', "\t" => '\\t'
            , "\r\n" => '\\n', "\n" => '\\n'));
    }

    /**#@-*/

    /*Protected****************************************************************/

    /**#@+
     * @access protected
     */

    function _def_params()
    {
        return array('Project-Id-Version' => '', 'Report-Msgid-Bugs-To' => ''
            , 'POT-Creation-Date' => date('Y-m-d h:iO'), 'PO-Revision-Date' => ''
            , 'Last-Translator' => '', 'Language-Team' => '', 'MIME-Version' => '1.0'
            , 'Content-Type' => 'text/plain; charset=UTF-8'
            , 'Content-Transfer-Encoding' => '8bit'
            , 'msgfmt' => '');
    }

    /**#@-*/

    /*Public*******************************************************************/

    function add_tr($token, $translation)
    {
        if (!is_resource($this->_fp)) return;
        $content = "\nmsgid \"" . $this->_escape_str($token) . "\"\n" . 'msgstr "'
            . $this->_escape_str($translation) . "\"\n";
        fwrite($this->_fp, $content);
    }

    function add_ntr($token, $translations)
    {
        if (!is_resource($this->_fp)) return;

        // count of translations should be equal to number of plural forms
        if (count($translations) != $this->_params['nplurals']) {
//            trigger_error('Missed some plural form', E_USER_WARNING);
            return;
        }

        $content = "\nmsgid \""  . $this->_escape_str($token) . "\"\nmsgid_plural \"\"\n";
        ksort($translations);
        $i = 0;
        foreach ($translations as $plural => $translation) {
            // some verbose checks must be performed
            // since if PO file will be with corrupted format
            // msgfmt will fail to compile it

            if (!is_numeric($plural)) {
                trigger_error(sprintf('Plural form number should be numberic.'
                    . ' "%s" received instead.', $plural), E_USER_WARNING);
                return;
            }

            if ($i++ != $plural) {
//                trigger_error('Missed some plural form', E_USER_WARNING);
                return;
            }

            if ($plural >= $this->_params['nplurals']) {
                trigger_error('Extra plural form received', E_USER_WARNING);
                return;
            }

            $content .= "msgstr[$plural] \"" . $this->_escape_str($translation) . "\"\n";
        }

        fwrite($this->_fp, $content);
    }

    /**
     * Clear language
     *
     * @param Locale $language
     */
    function clear_language(&$locale)
    {
        @FileSystem::rmr($this->_params['targetdir'] . '/' . $locale->lang_code());
    }

    /**
     * Open translation language
     *
     * If language directory not exists it will be created. Language directories
     * names are 2 letter lanuage codes. Language files are stored in LC_MESSAGES/
     * folder inside language directory.
     */
    function open_language(&$locale, $nplurals = 1, $expr = '')
    {
        if (!parent::open_language($locale, $nplurals, $expr)) return false;

        // set target directory
        $dirname = $this->_params['targetdir'] . '/' . $locale->lang_code() . '/LC_MESSAGES';

        // create target directory (if was not created yet)
        if (!@FileSystem::mkdir($dirname, 0755, true, SITE_PATH . '/' . LANGUAGES_PATH)) {
            trigger_error('Unable to create target directory for compiled language files: '
                . $dirname, E_USER_WARNING);
            return false;
        }

        // save path to lang directory
        $this->_lang_path = $dirname;

        return true;
    }

    /**
     * Open domain
     *
     * Open domain PO file for writing in current {@link _lang_path} directory
     * and write initial PO header into opened file.
     */
    function open_domain($domain)
    {
        if (!parent::open_domain($domain)) return false;

        $fname = $this->_lang_path . '/' . $domain . '.po';
        if (false === $this->_fp = @fopen($fname, 'w')) {
            trigger_error(sprintf('Unable to open "%s" for writing', $fname));
            return false;
        }

        $this->_write_header($this->_fp);
        return true;
    }

    /**
     * Compiles domian language file
     *
     * Closes opened domain PO file and executes msgfmt program against this file
     * to create compiled gettext language file.
     * <br />
     * It's not possible to redirect stderr to stdout with 2>&1 because if safe_mode
     * is on ampersand will be escaped with escapeshellcmd() causing corruption
     * of command. Since msgfmt write errors descriptions in stderr to get these
     * errors reported in this method you have to replace original msgfmt with
     * shell scrript that will redirect stderr of msgfmt to its stdout. For example
     * this script might look like:
     * <pre>
     * #!/bin/sh
     * msgfmt $@ 2>&1
     * </pre>
     *
     * @return bool
     */
    function compile_domain()
    {
        // close opened PO file
        if (!$this->_fp) return false;
        fclose($this->_fp);
        $this->_fp = null;

        // compile gettext language file
        $msgfmt = isset($this->_params['msgfmt']) ? $this->_params['msgfmt'] : 'msgfmt';
        $command = "$msgfmt -o $this->_lang_path/{$this->_params['domain']}.mo"
            . " $this->_lang_path/{$this->_params['domain']}.po";

        exec($command, $output = null, $return_val = null);
        unlink("$this->_lang_path/{$this->_params['domain']}.po");

        if (0 != $return_val) {
            trigger_error(sprintf('Unable to compile PO file. "%s"', implode("\n", $output))
                , E_USER_WARNING);
        }

        parent::compile_domain();
        return 0 == $return_val;
    }
}